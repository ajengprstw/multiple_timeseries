---
title: "Untitled"
author: "Team Algoritma"
date: "10/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidymodels)
```


```{r}
walmart <- read_csv("data/train_walmart.csv")
head(walmart)
```
```{r}
walmart_clean <- walmart %>% 
                 mutate(Date = ymd(Date)) %>% 
                 filter(Store %in% 1:5) %>%
                 group_by(Store,Date) %>% 
                 summarise(Sales = mean(Weekly_Sales)) %>% 
                 ungroup()

min_date <- min(walmart_clean$Date)
max_date <- max(walmart_clean$Date)
```
```{r}
data_clean <- walmart_clean %>% 
              group_by(Store) %>% 
              pad(start_val = min_date,end_val = max_date) %>% 
              ungroup()

colSums(is.na(data_clean))

```

```{r}
# visualize train
ggplot(data_clean, aes(x = Date, y = Sales)) +
  geom_line() +
  facet_wrap(~ Store, ncol = 2, scales = "free")+
  labs(title = "Weekly Sales by Store (Train Dataset)", x = NULL, y = NULL, colour = NULL)+
  theme_minimal()
```

```{r}
data_walmart <- forecastML::fill_gaps(data_clean, 
                                      date_col = 2,
                                      frequency = "1 week", 
                                      groups = "Store")
head(data_walmart)
```

```{r}
data_walmart %>% 
  filter(Store == 1)
```


```{r}
data_train <- forecastML::create_lagged_df(data_walmart, 
                                           type = "train", 
                                           outcome_col = 3,
                                           horizons = c(1,4,12),
                                           lookback = 1:48,
                                           dates = data_walmart$Date, 
                                           frequency = "1 week",
                                           dynamic_features = c("week","month"),
                                           groups = "Store",
                                           use_future = FALSE)
head(data_train)
```

```{r}
plot(data_train)+geom_tile()
```

```{r}
windows <- forecastML::create_windows(data_train, 
                                      window_length = 4*6, 
                                      skip = 4,
                                      include_partial_window = FALSE)

plot(windows, data_train) + theme(legend.position = "none")

```

```{r}
plot(windows, 
     data_train, 
     group_filter = "Store == 1") + 
  theme(legend.position = "none")
```


```{r}
# The value of outcome_col can also be set in train_model() with train_model(outcome_col = 1).
model_function <- function(data, outcome_col = 1) {
  
  # xgboost cannot handle missing outcomes data.
  data <- data[!is.na(data[, outcome_col]), ]

  indices <- 1:nrow(data)
  
  set.seed(100)
  train_indices <- sample(1:nrow(data), ceiling(nrow(data) * .8), replace = FALSE)
  test_indices <- indices[!(indices %in% train_indices)]

  data_train <- xgboost::xgb.DMatrix(data = as.matrix(data[train_indices, 
                                                           -(outcome_col), drop = FALSE]),
                                     label = as.matrix(data[train_indices, 
                                                            outcome_col, drop = FALSE]))

  data_test <- xgboost::xgb.DMatrix(data = as.matrix(data[test_indices, 
                                                          -(outcome_col), drop = FALSE]),
                                    label = as.matrix(data[test_indices, 
                                                           outcome_col, drop = FALSE]))

  params <- list("objective" = "reg:linear")
  watchlist <- list(train = data_train, test = data_test)
  
  set.seed(100)
  model <- xgboost::xgb.train(data = data_train, params = params, 
                              max.depth = 8, nthread = 2, nrounds = 30,
                              metrics = "rmse", verbose = 0, 
                              early_stopping_rounds = 5, 
                              watchlist = watchlist)

  return(model)
}
```

```{r}
head(data_train)
```



```{r}
model_results_cv <- forecastML::train_model(lagged_df = data_train,
                                            windows = windows,
                                            model_name = "xgboost",
                                            model_function = model_function, 
                                            use_future = FALSE)

?HoltWinters
```



=============================================

```{r}
library(forecastML)
data("data_buoy_gaps", package = "forecastML")

head(data_buoy_gaps)
```
```{r}
data <- forecastML::fill_gaps(data_buoy_gaps, date_col = 1, frequency = '1 day', 
                              groups = 'buoy_id', static_features = c('lat', 'lon'))
data$day <- lubridate::mday(data$date)
data$year <- lubridate::year(data$date)
```

```{r}
data$buoy_id <- as.numeric(factor(data$buoy_id))
outcome_col <- 1  # The column position of our 'wind_spd' outcome (after removing the 'date' column).

horizons <- c(1, 7, 30)  # Forecast 1, 1:7, and 1:30 days into the future.

lookback <- c(1:30, 360:370)  # Features from 1 to 30 days in the past and annually.

dates <- data$date  # Grouped time series forecasting requires dates.
data$date <- NULL  # Dates, however, don't need to be in the input data.

frequency <- "1 day"  # A string that works in base::seq(..., by = "frequency").

dynamic_features <- c("day", "year")  # Features that change through time but which will not be lagged.

groups <- "buoy_id"  # 1 forecast for each group or buoy.

static_features <- c("lat", "lon")
```

```{r}
type <- "train"  # Create a model-training dataset.

data_train <- forecastML::create_lagged_df(data, type = type, outcome_col = outcome_col,
                                           horizons = horizons, lookback = lookback,
                                           dates = dates, frequency = frequency,
                                           dynamic_features = dynamic_features,
                                           groups = groups, static_features = static_features, 
                                           use_future = FALSE)

head(data_train)
head(data_train$horizon_1)
```

```{r}
windows <- forecastML::create_windows(data_train, window_length = 365, skip = 730,
                                      include_partial_window = FALSE)

p <- plot(windows, data_train) + theme(legend.position = "none")
p
```
```{r}
model_function <- function(data, outcome_col = 1) {
  
  # xgboost cannot handle missing outcomes data.
  data <- data[!is.na(data[, outcome_col]), ]

  indices <- 1:nrow(data)
  
  set.seed(224)
  train_indices <- sample(1:nrow(data), ceiling(nrow(data) * .8), replace = FALSE)
  test_indices <- indices[!(indices %in% train_indices)]

  data_train <- xgboost::xgb.DMatrix(data = as.matrix(data[train_indices, 
                                                           -(outcome_col), drop = FALSE]),
                                     label = as.matrix(data[train_indices, 
                                                            outcome_col, drop = FALSE]))

  data_test <- xgboost::xgb.DMatrix(data = as.matrix(data[test_indices, 
                                                          -(outcome_col), drop = FALSE]),
                                    label = as.matrix(data[test_indices, 
                                                           outcome_col, drop = FALSE]))

  params <- list("objective" = "reg:linear")
  watchlist <- list(train = data_train, test = data_test)
  
  set.seed(224)
  model <- xgboost::xgb.train(data = data_train, params = params, 
                              max.depth = 8, nthread = 2, nrounds = 30,
                              metrics = "rmse", verbose = 0, 
                              early_stopping_rounds = 5, 
                              watchlist = watchlist)

  return(model)
}
```

```{r}
model_results_cv <- forecastML::train_model(lagged_df = data_train,
                                            windows = windows,
                                            model_name = "xgboost",
                                            model_function = model_function, 
                                            use_future = FALSE)
```

```{r}
summary(model_results_cv$horizon_1$window_1$model)
```

```{r}

```

